pragma solidity 0.6.4;
pragma experimental ABIEncoderV2;

import "github.com/OpenZeppelin/openzeppelin-contracts/contracts/math/SafeMath.sol";

import "../interfaces/IDepositExecute.sol";
import "./HandlerHelpers.sol";
import "../utils/seroInterface.sol";

interface ISRC20Mintable  {
    function mint(uint256 total) external;
    function burn() external payable;
}

/**
    @title Handles ERC20 deposits and deposit executions.
    @author ChainSafe Systems.
    @notice This contract is intended to be used with the Bridge contract.
 */
contract SRC20Handler is IDepositExecute, HandlerHelpers,SeroInterface {

    using SafeMath for uint256;

    struct DepositRecord {
        address _tokenAddress;
        uint8    _lenDestinationRecipientAddress;
        uint8   _destinationChainID;
        bytes32 _resourceID;
        bytes   _destinationRecipientAddress;
        address _depositer;
        uint    _amount;
    }

    // depositNonce => Deposit Record
    mapping (uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;


    constructor(
        address          bridgeAddress
    ) public {

        _bridgeAddress = bridgeAddress;
    }

    /**
        @param depositNonce This ID will have been generated by the Bridge contract.
        @param destId ID of chain deposit will be bridged to.
        @return DepositRecord which consists of:
        - _tokenAddress Address used when {deposit} was executed.
        - _destinationChainID ChainID deposited tokens are intended to end up on.
        - _resourceID ResourceID used when {deposit} was executed.
        - _lenDestinationRecipientAddress Used to parse recipient's address from {_destinationRecipientAddress}
        - _destinationRecipientAddress Address tokens are intended to be deposited to on desitnation chain.
        - _depositer Address that initially called {deposit} in the Bridge contract.
        - _amount Amount of tokens that were deposited.
    */
    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {
        return _depositRecords[destId][depositNonce];
    }


    function deposit(
        bytes32 resourceID,
        uint8   destinationChainID,
        uint64  depositNonce,
        address depositer,
        bytes calldata recipient
    ) external override payable  onlyBridge {


        address tokenAddress = _resourceIDToTokenContractAddress[resourceID];

        string memory resourceToCurrency  = _resourceIDToCurrency[resourceID];

        string memory _cy = sero_msg_currency();

        require(equals(resourceToCurrency,_cy),"invalid currency");

        if (tokenAddress!= address(0)){
            ISRC20Mintable src20 = ISRC20Mintable(tokenAddress);
            sero_setCallValues(resourceToCurrency,msg.value,"",0);
            src20.burn();
        }


        _depositRecords[destinationChainID][depositNonce] = DepositRecord(
            tokenAddress,
            uint8(recipient.length),
            destinationChainID,
            resourceID,
            recipient,
            depositer,
            msg.value
        );
    }

    function executeProposal(bytes32 resourceID,address _recipient,uint256 amount) external override onlyBridge {


        if (_resourceIDToTokenContractAddress[resourceID] != address(0)){
            ISRC20Mintable src20 = ISRC20Mintable(_resourceIDToTokenContractAddress[resourceID]);
            src20.mint(amount);
        }
        require(sero_send_token(_recipient,_resourceIDToCurrency[resourceID],amount),"send to recipient failed");

    }

    function transferFee(bytes32 resourceID, address  gasFeeRecipient,uint256 gasFee,address[] calldata relayers, uint256 relayFee) external override onlyBridge{
        address tokenAddress = _resourceIDToTokenContractAddress[resourceID];

        if (tokenAddress != address(0) && (gasFee.add(relayFee) >0)) {
            ISRC20Mintable src20 = ISRC20Mintable(tokenAddress);
            src20.mint(gasFee.add(relayFee));

        }

        if (gasFee > 0){
            require(sero_send_token(gasFeeRecipient,_resourceIDToCurrency[resourceID],gasFee),"send to recipient failed");

        }

        if (relayFee >0){
            for(uint256 i =0;i<relayers.length;i++){
                require(sero_send_token(relayers[i],_resourceIDToCurrency[resourceID],relayFee/relayers.length),"send to recipient failed");
            }
        }


    }



    function withdraw(string calldata currency, address recipient, uint amount) external override onlyBridge {
        require(sero_send_token(recipient,currency,amount),"withdraw to recipient failed");

    }


    receive() external payable{

    }
}
