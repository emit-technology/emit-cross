// SPDX-License-Identifier: MIT

pragma solidity >=0.6.0 <0.8.0;

pragma experimental ABIEncoderV2;

import "../utils/SafeMath.sol";

import "./IDepositExecute.sol";
import "./HandlerHelpers.sol";
import "../utils/seroInterface.sol";
import "./EnumerableMap.sol";
import "../token/ISRC721.sol";


/**
    @title Handles ERC20 deposits and deposit executions.
    @author ChainSafe Systems.
    @notice This contract is intended to be used with the Bridge contract.
 */
contract SRC721Handler is IDepositExecute, HandlerHelpers,SeroInterface {

    using SafeMath for uint256;

    using EnumerableMap for EnumerableMap.Bytes32ToUintMap;

    mapping(bytes32 => EnumerableMap.Bytes32ToUintMap) resourceIDToLockedTicket;

    struct DepositRecord {
        address _tokenAddress;
        uint8   _destinationChainID;
        bytes32 _ticketResourceID;
        bytes   _destinationRecipientAddress;
        address _depositer;
        uint    _tokenID;
        bytes _metaData;
        uint amount;
    }

    // depositNonce => Deposit Record
    mapping (uint8 => mapping(uint64 => DepositRecord)) public _depositRecords;

    constructor(
        address          bridgeAddress
    ) public {

        _bridgeAddress = bridgeAddress;
    }

    /**
        @param depositNonce This ID will have been generated by the Bridge contract.
        @param destId ID of chain deposit will be bridged to.
        @return DepositRecord which consists of:
        - _tokenAddress Address used when {deposit} was executed.
        - _destinationChainID ChainID deposited tokens are intended to end up on.
        - _resourceID ResourceID used when {deposit} was executed.
        - _lenDestinationRecipientAddress Used to parse recipient's address from {_destinationRecipientAddress}
        - _destinationRecipientAddress Address tokens are intended to be deposited to on desitnation chain.
        - _depositer Address that initially called {deposit} in the Bridge contract.
        - _amount Amount of tokens that were deposited.
    */
    function getDepositRecord(uint64 depositNonce, uint8 destId) external view returns (DepositRecord memory) {
        return _depositRecords[destId][depositNonce];
    }


    function deposit(
        bytes32 resourceID,
        uint8   destinationChainID,
        uint64  depositNonce,
        address depositer,
        bytes calldata recipient
    ) external override payable  onlyBridge {


        address ticketAddress = _resourceIDToContractAddress[resourceID];

        string memory resourceToCategory  = _resourceIDToCategory[resourceID];

        string memory _catg = sero_msg_category();

        bytes32 _tkt = sero_msg_ticket();

        require(equals(resourceToCategory,_catg),"invalid category");


        ISRC721Mintable src721 = ISRC721Mintable(ticketAddress);

        if (_burnList[ticketAddress]){
            sero_setCallValues("",0,_catg,_tkt);
            src721.burn();
        }else {
            resourceIDToLockedTicket[resourceID].set(_tkt,src721.ticketId(_tkt));
        }

        if (msg.value >0){
            require(sero_send_token(_resourceIDToFeeHandler[resourceID],sero_msg_currency(),msg.value),"send fee failed");
        }

        _depositRecords[destinationChainID][depositNonce] = DepositRecord(
            ticketAddress,
            destinationChainID,
            resourceID,
            recipient,
            depositer,
            src721.ticketId(_tkt),
            bytes(src721.ticketURI(_tkt)),
            msg.value
        );
    }

    function executeProposal(bytes32 resourceID,address _recipient,uint256 ticketId,bytes calldata metaData) external override onlyBridge {

        address ticketAddress = _resourceIDToContractAddress[resourceID];

        ISRC721Mintable src721 = ISRC721Mintable(ticketAddress);

        bytes32 ticket = bytes32(0);

        if (_burnList[ticketAddress]){

            ticket = src721.mint(_recipient,ticketId);
            src721.setTicketURI(ticket, string(metaData));

        }else {
            ticket = src721.ticket(ticketId);
            require(sero_send_ticket(_recipient,_resourceIDToCategory[resourceID],ticket),"send ticket failed");
            resourceIDToLockedTicket[resourceID].remove(ticket);
        }

    }

    function tokenByIndex(bytes32 resourceID,uint256 index) external view returns (bytes32){
        (bytes32 tokenId, ) = resourceIDToLockedTicket[resourceID].at(index);
        return tokenId;
    }

    function balanceOfResoruceID(bytes32 resourceID) external view returns(uint256){
        return resourceIDToLockedTicket[resourceID].length();
    }

    function balanceOfCategory(string calldata category) external view returns(uint256){

        bytes32 resourceID = _categoryToResourceID[category];

        return resourceIDToLockedTicket[resourceID].length();
    }



    function withdraw(string calldata category, address recipient, bytes32 tkt) external override onlyBridge {
        require(sero_send_ticket(recipient,category,tkt),"withdraw to recipient failed");
        bytes32 resourceID = _categoryToResourceID[category];
        resourceIDToLockedTicket[resourceID].remove(tkt);

    }


receive() external payable{

}
}
